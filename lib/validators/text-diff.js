// Generated by CoffeeScript 1.7.1
var DiffMatchPatch, TextDiff, ValidationErrors, errors;

ValidationErrors = require('./validation-errors').ValidationErrors;

errors = require('../errors');

DiffMatchPatch = require('googlediff');

TextDiff = (function() {
  function TextDiff(real, expected) {
    var outError;
    this.real = real;
    this.expected = expected;
    if (typeof this.real !== 'string') {
      outError = new errors.DataNotStringError('String validator real: input data is not string');
      outError['data'] = this.real;
      throw outError;
    }
    if (typeof this.expected !== 'string') {
      outError = new errors.DataNotStringError('String validator expected: input data is not string');
      outError['data'] = this.expected;
      throw outError;
    }
  }

  TextDiff.prototype.validate = function() {
    var dmp, e, patch, sanitizeSurrogatePairs;
    sanitizeSurrogatePairs = function(data) {
      return data.replace(/[\uD800-\uDBFF]/g, '').replace(/[\uDC00-\uDFFF]/g, '');
    };
    this.output = null;
    dmp = new DiffMatchPatch;
    try {
      patch = dmp.patch_make(this.real, this.expected);
      this.output = dmp.patch_toText(patch);
      return this.output;
    } catch (_error) {
      e = _error;
      if (e instanceof URIError) {
        patch = dmp.patch_make(sanitizeSurrogatePairs(this.real), sanitizeSurrogatePairs(this.expected));
        this.output = dmp.patch_toText(patch);
        return this.output;
      } else {
        throw e;
      }
    }
  };

  TextDiff.prototype.evaluateOutputToResults = function(data) {
    if (!data) {
      data = this.output;
    }
    if (!data) {
      return [];
    }
    return [
      {
        severity: 'error',
        message: 'Real and expected data does not match.'
      }
    ];
  };

  TextDiff.prototype.getHash = function(data) {
    return crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');
  };

  return TextDiff;

})();

module.exports = {
  TextDiff: TextDiff
};
